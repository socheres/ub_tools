/** \file add_authority_wikidata_ids.cc
 *  \brief functionality to acquire wikidata id corresponding to their gnds
 *  \author andreas-ub
 *  \author Steven Lolong (steven.lolong@uni-tuebingen.de)
 *
 *  \copyright 2021 Universit채tsbibliothek T체bingen.  All rights reserved.
 *  \copyright 2022 Universit채tsbibliothek T체bingen.  All rights reserved.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <chrono>
#include <fstream>
#include <iostream>
#include <regex>
#include <string>
#include <nlohmann/json.hpp>
#include "BeaconFile.h"
#include "FileUtil.h"
#include "MARC.h"
#include "StringUtil.h"
#include "TextUtil.h"
#include "util.h"

/**
 * ============= Generate gnd_to_wiki ===============
 * New scenario to generate gnd_to_wiki.txt
 * by Steven Lolong
 * update-1: 16.12.2022
 *
 * Case of "generate_gnd_to_wiki"
 * The input file is the file generated by this command:
 *      jq -c --stream '.' < authorities-gnd-person_lds.jsonld |grep -E 'https\\:/\\/d-nb\\.info\\/gnd\\/|wikidata|wikipedia'
 * where authorities-gnd-person_lds_*.jsonld.gz is the file downloaded from "https://data.dnb.de/opendata/". Since the file is in zip
 format,
 * therefore it needs to extracted first with "gunzip" or something like that.
 * Ex. syntax:
 * jq -c --stream '.' < authorities-gnd-person_lds.jsonld |grep -E 'https\:/\/d-nb\.info\/gnd\/|wikidata|wikipedia' >
 input_file_for_add_authority_external_ref.txt
 *
 * The example of a valid line from input file:
 *  [[0,14023,"@id"],"https://d-nb.info/gnd/10011769433"]
    [[0,14023,"http://www.w3.org/2002/07/owl#sameAs",2,"@id"],"http://www.wikidata.org/entity/Q51857205"]
    [[0,14023,"http://www.w3.org/2007/05/powder-s#describedby",0,"@id"],"https://d-nb.info/gnd/100117694/about"]
    [[0,14023,"http://xmlns.com/foaf/0.1/page",0,"@id"],"https://de.wikipedia.org/wiki/Jean-Philippe_Dutoit-Membrini"]
    [[0,14023,"https://d-nb.info/standards/elementset/gnd#placeOfBirth",0,"@id"],"https://d-nb.info/gnd/4115248-7"]
    [[0,14023,"https://d-nb.info/standards/elementset/gnd#professionOrOccupation",0,"@id"],"https://d-nb.info/gnd/4059756-8"]
    [[0,14024,"@id"],"https://d-nb.info/gnd/100117694/about"]
    [[0,14025,"@id"],"https://d-nb.info/gnd/100117813"]
    [[0,14025,"http://www.w3.org/2007/05/powder-s#describedby",0,"@id"],"https://d-nb.info/gnd/100117813/about"]
    [[0,14026,"@id"],"https://d-nb.info/gnd/100117813/about"]
 *
 * The output file is in new format, it uses csv format with structure:
 *      GND-ID;Wikidata-Entity-Id;Wikipedia-Address
 * The example lines of output file:
    "115829253";"Q434171";"https://de.wikipedia.org/wiki/Michael_William_Balfe"
    "11582927X";"";""
    "115829296";"Q6220430";""
 *
 */

// Scenario 1:
// use --create_mapping_file parameter <filepath> to generate the mapping file
//  of the downloaded dnb authoriy dump (must bei unzipped first)
//  Download from: https://data.dnb.de/opendata/authorities-gnd-person_lds.jsonld.gz
//  and unzip to e.g. authorities-gnd-person_lds_20210613.jsonld
//  output is stdout
// Scenario 2:
// use converted file from scenario 1 from cpp/data to create a map during
//  pipeline processing. The norm_data_input is extended by wikidata ids where possible
//  and saved to 024 field indicator1:7 where wikidata id is not yet present
//  file can be taken from /mnt/ZE020150/FID-Entwicklung/ub_tools (gnd_to_wiki.txt)
[[noreturn]] void Usage() {
    ::Usage(
        "\t:\n"
        "\tinvocation modes:\n"
        "\t1.)  norm_data_marc_input norm_data_marc_output mapping_txt_file\n"
        "\t2.)  --create_mapping_file dnb_input_unzipped_file mapping_txt_file\n"
        "\t3.)  --generate_gnd_to_wiki input_file.txt output_file.csv summary.txt"
        "\n\n"
        "--generate_gnd_to_wiki input_file.txt output_file.csv summary.txt\n"
        "\t- input_file.txt: the file that generated with command: \n"
        "\t\tjq -c --stream '.' < authorities-gnd-person_lds.jsonld |grep -E 'https\\:/\\/d-nb\\.info\\/gnd\\/|wikidata|wikipedia'\n"
        "\t- output_file.csv: the gnd_to_wiki file to write to, it is a csv with ';' as delimiter.\n"
        "\t\tThe format: \n"
        "\t\t\tGND-ID;Wikidata-Entity-Id;Wikipedia-Address\n"
        "\t- summary.txt: the file will contain the final report about the total number of GND, Wikidata, and Wikipedia");
}


void ParseDataDnbFile(std::string input_filename, std::string output_filename) {
    std::ifstream input_file(input_filename);
    std::ofstream output_file(output_filename);
    if (input_file.is_open() and output_file.is_open()) {
        std::string line;
        std::string act_gnd;
        std::string act_name;
        std::string act_wikidata;
        std::string act_wikipedia;
        bool sameAs_reached(false);
        bool read_preferred_name(false);
        bool read_gnd_id(false);
        while (std::getline(input_file, line)) {
            if (line == "}, {") {
                if (not act_gnd.empty() and not act_name.empty() and not act_wikidata.empty()) {
                    output_file << "Name: " << act_name << " GND: " << act_gnd << " Wikidata: " << act_wikidata
                                << " Wikipedia: " << act_wikipedia << "\n";
                }
                act_gnd = "";
                act_name = "";
                act_wikidata = "";
                act_wikipedia = "";
                sameAs_reached = false;
                read_gnd_id = true;
            } else if (read_preferred_name) {
                read_preferred_name = false;
                act_name = std::regex_replace(line, std::regex("(value|:|\"|@)"), "");
                act_name = StringUtil::TrimWhite(act_name);
            } else if (StringUtil::Contains(line, "info/gnd/") and read_gnd_id) {
                read_gnd_id = false;
                std::size_t last_slash = line.find_last_of("/");
                act_gnd = line.substr(last_slash + 1);
                act_gnd = std::regex_replace(act_gnd, std::regex("(\\s|,|\")"), "");
            } else if (StringUtil::Contains(line, "www.wikidata.org/entity/") and sameAs_reached) {
                std::size_t last_slash = line.find_last_of("/");
                act_wikidata = line.substr(last_slash + 1);
                act_wikidata = std::regex_replace(act_wikidata, std::regex("(\\s|,|\")"), "");
            } else if (StringUtil::Contains(line, "wikipedia.org/wiki/") and StringUtil::Contains(line, "http") and sameAs_reached) {
                std::size_t first_http = line.find("http");
                act_wikipedia = line.substr(first_http);
                act_wikipedia = std::regex_replace(act_wikipedia, std::regex("(\\s|,|\")"), "");
            } else if (StringUtil::Contains(line, "owl#sameAs")) {
                sameAs_reached = true;
            } else if (StringUtil::Contains(line, "preferredNameForThePerson")) {
                read_preferred_name = true;
            }
        }
        input_file.close();
        output_file.close();
    } else
        LOG_ERROR("input or output files could not be opened");
}


void ParseGndWikidataMappingFile(std::string filename,
                                 std::unordered_map<std::string, std::vector<std::string>> * const gnd_to_wikidataid_and_wikipedia_link) {
    std::ifstream file(filename);
    if (file.is_open()) {
        std::string line;
        std::string act_gnd;
        std::string act_wikidata;
        std::string act_wikipedia;
        while (std::getline(file, line)) {
            const std::string NAME = "Name:";
            const std::string GND = "GND:";
            const std::string WIKIDATA = "Wikidata:";
            const std::string WIKIPEDIA = "Wikipedia:";
            if (StringUtil::StartsWith(line, NAME) and StringUtil::Contains(line, GND) and StringUtil::Contains(line, WIKIDATA)
                and StringUtil::Contains(line, WIKIPEDIA))
            {
                act_gnd = line.substr(line.find(GND) + GND.length());
                act_gnd = act_gnd.substr(0, act_gnd.find(WIKIDATA));
                act_wikidata = line.substr(line.find(WIKIDATA) + WIKIDATA.length());
                act_wikidata = act_wikidata.substr(0, act_wikidata.find(WIKIPEDIA));
                act_wikipedia = line.substr(line.find(WIKIPEDIA) + WIKIPEDIA.length());
                std::vector<std::string> wiki_elements = { StringUtil::TrimWhite(act_wikidata), StringUtil::TrimWhite(act_wikipedia) };
                gnd_to_wikidataid_and_wikipedia_link->emplace(StringUtil::TrimWhite(act_gnd), wiki_elements);
            }
        }
        file.close();
    } else
        LOG_ERROR("input or output files could not be opened");
}

struct GNDStructure {
    std::string gnd_id, wikidata_personal_entity_id, wikipedia_personal_address;
};

bool IsThisCloseBracketForId(const std::string &url) {
    int url_length = url.length();
    std::string is_about(url.substr(url_length - 5, 5));
    if (is_about.compare("about") == 0)
        return true;

    return false;
}

bool DoesItMatch(const std::string &url_based, const std::string &url_comp) {
    const int base_string_lenght = url_based.length();
    const std::string sub_string_url_comp = url_comp.substr(0, base_string_lenght);
    if (url_based.compare(sub_string_url_comp) == 0)
        return true;

    return false;
}

int GenerateGNDAuthorityExternalRef(char *argv[]) {
    auto load_file_start = std::chrono::high_resolution_clock::now();
    std::ifstream input_file(argv[2]);
    std::ofstream summary_file(argv[4]);

    if (!input_file.is_open()) {
        LOG_ERROR("can't open input file");
        return 1;
    }

    const auto csv_file(FileUtil::OpenOutputFileOrDie(argv[3]));


    const std::string d_nb_address("https://d-nb.info/gnd/");
    const std::string wikidata_address("http://www.wikidata.org/entity/");
    const std::string wikipedia_address("https://de.wikipedia.org/wiki/");
    std::string gnd_id;
    bool is_start_group = false;
    GNDStructure gnd_data;
    int top_level_number(-1), second_level_number(-1), total_numbers_of_gnd_id_generated(0), total_line_parsed(0),
        total_number_of_wikidata(0), total_number_of_wikipedia(0);

    const int d_nb_add_str_lenght(d_nb_address.length()), wikidata_address_str_lenght(wikidata_address.length());

    std::string line, id_annotaton(""), second_element_of_array;
    nlohmann::json line_parsed;
    std::string gnd_id_temp_string;
    std::string wikidata_temp_string;
    std::string tmp_id;


    while (std::getline(input_file, line)) {
        line_parsed = nlohmann::json::parse(line);
        // get information on first element of array
        if (line_parsed[0].is_array() && line_parsed[0][2].is_string()) {
            id_annotaton = line_parsed[0][2].get<std::string>();
            if (id_annotaton.compare("@id") == 0) {
                // the second element of array is not an array nor object
                if (!line_parsed[1].is_structured()) {
                    // if id without about, this means the beginning of group or opening bracket.
                    if (!IsThisCloseBracketForId(line_parsed[1])) {
                        // get gnd id, set is_start_group to true, set top_level_number, set second_level_number
                        // tmp_id = nlohmann::to_string(line_parsed[1]);
                        if (line_parsed[1].is_string()) {
                            top_level_number = line_parsed[0][0].get<int>();
                            second_level_number = line_parsed[0][1].get<int>();
                            is_start_group = true;
                            gnd_id_temp_string = line_parsed[1].get<std::string>();
                            gnd_data.gnd_id =
                                gnd_id_temp_string.substr(d_nb_add_str_lenght, (gnd_id_temp_string.length() - d_nb_add_str_lenght));

                            ++total_numbers_of_gnd_id_generated;
                        }
                    }
                }
                // if id -> about, this means the last of group or this is the closing bracket.
                // then print the accumulation of last result data and reset all info
                if (IsThisCloseBracketForId(line_parsed[1])) {
                    csv_file->write(TextUtil::CSVEscape(gnd_data.gnd_id) + ";");
                    csv_file->write(TextUtil::CSVEscape(gnd_data.wikidata_personal_entity_id) + ";");
                    csv_file->write(TextUtil::CSVEscape(gnd_data.wikipedia_personal_address) + "\n");
                    top_level_number = -1;
                    second_level_number = -1;
                    is_start_group = false;
                    gnd_id_temp_string = "";
                    gnd_data = {};
                }
            }

            if (is_start_group) {
                // std::cout << top_level_number << " , " << second_level_number << std::endl;
                if (line_parsed[0][0].get<int>() == top_level_number && line_parsed[0][1].get<int>() == second_level_number) {
                    if (!line_parsed[1].is_structured()) {
                        if (line_parsed[1].is_string()) {
                            if (DoesItMatch(wikipedia_address, line_parsed[1].get<std::string>())) {
                                gnd_data.wikipedia_personal_address = line_parsed[1].get<std::string>();

                                ++total_number_of_wikipedia;
                            }

                            // if wikidata
                            if (DoesItMatch(wikidata_address, line_parsed[1].get<std::string>())) {
                                wikidata_temp_string = nlohmann::to_string(line_parsed[1]);
                                gnd_data.wikidata_personal_entity_id = wikidata_temp_string.substr(
                                    wikidata_address_str_lenght + 1, (wikidata_temp_string.length() - (wikidata_address_str_lenght + 2)));

                                ++total_number_of_wikidata;
                            }
                        }
                    }
                }
            }
        }
        std::cout << "\r"
                  << "Parsed: " << total_line_parsed << " line(s), "
                  << " Total GND-ID: " << total_numbers_of_gnd_id_generated << ", Total GND with Wikidata: " << total_number_of_wikidata
                  << ", Total GND with Wikipedia: " << total_number_of_wikipedia;
        //   << "GND-ID url: " << tmp_id;
        std::cout.flush();
        ++total_line_parsed;
    }

    auto load_file_end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::seconds>(load_file_end - load_file_start);

    std::cout << std::endl << "Total time of computation: " << duration.count() << " second(s)" << std::endl;
    summary_file << "Total GND-ID: " << total_numbers_of_gnd_id_generated << std::endl
                 << "Total GND with Wikidata: " << total_number_of_wikidata << std::endl
                 << "Total GND with Wikipedia: " << total_number_of_wikipedia << std::endl;
    summary_file << "Total time of computation: " << duration.count() << " second(s)" << std::endl;

    input_file.close();
    summary_file.close();
    return 0;
}

int Main(int argc, char *argv[]) {
    if (argc < 4)
        Usage();

    const std::string marc_input_filename_or_create_flag(argv[1]);
    const std::string marc_output_filename_or_dnb_input(argv[2]);
    const std::string mapping_txt_filename(argv[3]);

    if (marc_input_filename_or_create_flag == "--create_mapping_file") {
        // e.g. "/..../authorities-person_lds_20210613.jsonld" and /usr/local/ub_tools/cpp/data/gnd_to_wiki.txt
        ParseDataDnbFile(marc_output_filename_or_dnb_input, mapping_txt_filename);
        return EXIT_SUCCESS;
    }
    if (marc_input_filename_or_create_flag == "--generate_gnd_to_wiki") {
        if (argc != 5)
            Usage();

        if (GenerateGNDAuthorityExternalRef(argv) == 0)
            return EXIT_SUCCESS;

        return EXIT_FAILURE;
    }

    std::unordered_map<std::string, std::vector<std::string>> gnd_to_wikielements;
    ParseGndWikidataMappingFile(mapping_txt_filename, &gnd_to_wikielements);

    std::unique_ptr<MARC::Reader> marc_reader(MARC::Reader::Factory(marc_input_filename_or_create_flag));
    std::unique_ptr<MARC::Writer> marc_writer(MARC::Writer::Factory(marc_output_filename_or_dnb_input));

    if (unlikely(marc_input_filename_or_create_flag == marc_output_filename_or_dnb_input))
        LOG_ERROR("Norm data input file name equals output file name!");

    while (MARC::Record record = marc_reader.get()->read()) {
        // 035|a (DE-588)118562215
        std::string record_gnd;
        std::string wikidata_id;
        std::string wikidata_id_orig;
        std::string wikipedia_link;
        std::string wikipedia_link_orig;
        std::vector<std::string> wiki_elements;

        MARC::GetGNDCode(record, &record_gnd);
        MARC::GetWikidataId(record, &wikidata_id_orig);
        MARC::GetWikipediaLink(record, &wikipedia_link_orig);

        // record lookup
        if (not record_gnd.empty()) {
            auto gnd_to_wikielements_iter = gnd_to_wikielements.find(record_gnd);
            if (gnd_to_wikielements_iter != gnd_to_wikielements.end()) {
                wiki_elements = gnd_to_wikielements_iter->second;
                if (wiki_elements.size() > 0)
                    wikidata_id = wiki_elements[0];
                if (wiki_elements.size() > 1)
                    wikipedia_link = wiki_elements[1];
            }
        }

        if (not wikidata_id.empty() and wikidata_id_orig != wikidata_id)
            record.insertField("024", { { 'a', wikidata_id }, { '2', "wikidata" }, { '9', "PipeLineGenerated" } }, /*indicator 1*/ '7');
        if (not wikipedia_link.empty() and wikipedia_link != wikipedia_link_orig)
            record.insertField("670", { { 'a', "Wikipedia" }, { 'u', wikipedia_link }, { '9', "PipeLineGenerated" } });

        marc_writer.get()->write(record);
    }

    return EXIT_SUCCESS;
}

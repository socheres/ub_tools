/**
 * \brief Utility for updating issn information
 * \author Steven Lolong (steven.lolong@uni-tuebingen.de)
 *
 * \copyright 2023 TÃ¼bingen University Library.  All rights reserved.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <iostream>
#include "CORE.h"
#include "FileUtil.h"
#include "MARC.h"
#include "util.h"

namespace {


[[noreturn]] void Usage() {
    ::Usage(
        "marc_input_articles marc_input_journals marc_output_articles"
        "\n"
        "- marc_input_articles is a file containing all article information taken from CORE.\n"
        "- marc_input_journals is a file containing journal information. Please use issn_lookup.py to generate this file.\n"
        "- marc_output_articles is an output file generated by this tool.\n");

    std::exit(EXIT_FAILURE);
}


struct SubFieldInfo {
    std::string t_;
    std::string w_;
    std::string x_;
    std::string l_; // this is for reference issn from main
    int online_version_counter_;
    int printed_version_counter_;
    bool is_online_;
    bool is_valid_;

    SubFieldInfo() {
        online_version_counter_ = 0;
        printed_version_counter_ = 0;
        is_valid_ = false;
        is_online_ = false;
        t_ = "";
        w_ = "";
        x_ = "";
        l_ = "";
    }

    SubFieldInfo(MARC::Record &record) {
        online_version_counter_ = 0;
        printed_version_counter_ = 0;
        is_valid_ = false;
        is_online_ = false;
        for (auto &field : record) {
            if (field.getTag() == "001")
                w_ = "(DE-627)" + field.getContents();

            if (field.getTag() == "022") {
                x_ = field.getFirstSubfieldWithCode('a');
                l_ = field.getFirstSubfieldWithCode('l');
            }

            if (field.getTag() == "245") {
                MARC::Subfields subfields(field.getSubfields());
                std::string subfield_a(subfields.getFirstSubfieldWithCode('a'));
                std::string subfield_b(subfields.getFirstSubfieldWithCode('b'));
                if ((not subfield_a.empty()) && (not subfield_b.empty()))
                    t_ = subfield_a + " " + subfield_b;
                else if ((not subfield_a.empty()) && subfield_b.empty())
                    t_ = subfield_a;
                else if (subfield_a.empty() && (not subfield_b.empty()))
                    t_ = subfield_b;
                else
                    t_ = "";
            }

            if (field.getTag() == "300")
                is_online_ = (field.getFirstSubfieldWithCode('a') == "Online-Ressource");
        }
    }
};


void UpdateSubfield(MARC::Subfields &subfields, const SubFieldInfo &sub_field_info) {
    if (!subfields.replaceFirstSubfield('i', "In:"))
        subfields.addSubfield('i', "In:");
    if (!subfields.replaceFirstSubfield('x', sub_field_info.x_))
        subfields.addSubfield('x', sub_field_info.x_);
    if (!subfields.replaceFirstSubfield('w', sub_field_info.w_))
        subfields.addSubfield('w', sub_field_info.w_);

    if (not sub_field_info.t_.empty()) {
        if (!subfields.replaceFirstSubfield('t', sub_field_info.t_))
            subfields.addSubfield('t', sub_field_info.t_);
    }
}


void UpdateJournalValidity(std::map<std::string, SubFieldInfo> &journal_cache, std::map<std::string, SubFieldInfo> &online_issn_cache,
                           std::map<std::string, SubFieldInfo> &print_issn_cache) {
    // check whether the issn is occur more than once
    // unsigned online_valid(0), online_invalid(0), print_valid(0), print_invalid(0);

    LOG_INFO("Cache contents:");
    // check online issn
    auto online_sfi = online_issn_cache.cbegin();
    while (online_sfi != online_issn_cache.cend()) {
        auto curr_online_sfi = online_sfi++;
        if (curr_online_sfi->second.online_version_counter_ == 1) {
            // add to journal_cache
            journal_cache.emplace(curr_online_sfi->first, curr_online_sfi->second);

            // set status to valid
            journal_cache[curr_online_sfi->second.x_].is_valid_ = true;

            auto print_issn = print_issn_cache.cbegin();
            while (print_issn != print_issn_cache.cend()) {
                // check whether the online issn has a refence from the printed version
                auto curr_print_issn = print_issn++;
                if (not curr_print_issn->second.l_.empty() && (curr_print_issn->second.l_ == curr_online_sfi->second.x_)) {
                    // erase the printed version refers to this online issn
                    print_issn_cache.erase(print_issn);
                }

                // check whether there is a same issn with print version and the print version has no reference to online version
                if (curr_print_issn->second.l_.empty() && (curr_print_issn->second.x_ == curr_online_sfi->second.l_)) {
                    // the printed version refers to this online issn
                    print_issn_cache.erase(print_issn);
                }
            }
            online_issn_cache.erase(curr_online_sfi);
        }
        if (curr_online_sfi->second.online_version_counter_ > 1) {
            auto print_issn = print_issn_cache.cbegin();
            while (print_issn != print_issn_cache.cend()) {
                // check whether the online issn has a refence from the printed version
                auto curr_print_issn = print_issn++;
                if (not curr_print_issn->second.l_.empty() && (curr_print_issn->second.l_ == curr_online_sfi->second.x_)) {
                    // delete the printed version refers to this online issn
                    print_issn_cache.erase(curr_print_issn);
                }

                // check whether there is a same issn with print version and the print version has no reference to online version
                if (curr_print_issn->second.l_.empty() && (curr_print_issn->second.x_ == curr_online_sfi->second.l_)) {
                    // delete the printed version refers to this online issn
                    print_issn_cache.erase(curr_print_issn);
                }
            }
            online_issn_cache.erase(curr_online_sfi);
        }
    }
    auto print_sfi = print_issn_cache.cbegin();
    while (print_sfi != print_issn_cache.cend()) {
        auto curr_print_sfi = print_sfi++;
        if (curr_print_sfi->second.printed_version_counter_ == 1) {
            journal_cache.emplace(curr_print_sfi->first, curr_print_sfi->second);
            journal_cache[curr_print_sfi->second.x_].is_valid_ = true;
        }
    }
    // LOG_INFO("Online (valid): " + std::to_string(online_valid) + ", " + "Online (invalid): " + std::to_string(online_invalid) + ", "
    //          + "Print (valid): " + std::to_string(print_valid) + ", " + "Print (invalid): " + std::to_string(print_invalid));
}


std::map<std::string, SubFieldInfo> BuildJournalCache(const std::string &input_journal_filename) {
    std::map<std::string, SubFieldInfo> journal_cache, online_issn_cache, printed_issn_cache;
    auto input_journal_file(MARC::Reader::Factory(input_journal_filename));
    int record_counter(0);


    while (MARC::Record record = input_journal_file->read()) {
        SubFieldInfo sub_field_info_of_record(record);

        // online issn
        if (sub_field_info_of_record.is_online_) {
            if (online_issn_cache.find(sub_field_info_of_record.x_) != online_issn_cache.end()) {
                // it is in online cache already
                ++online_issn_cache[sub_field_info_of_record.x_].online_version_counter_;
            } else {
                online_issn_cache.emplace(sub_field_info_of_record.x_, sub_field_info_of_record);
            }
        }
        // print issn
        else
        {
            if (printed_issn_cache.find(sub_field_info_of_record.x_) != printed_issn_cache.end()) {
                // it is in print cache already
                ++online_issn_cache[sub_field_info_of_record.x_].online_version_counter_;
            } else {
                printed_issn_cache.emplace(sub_field_info_of_record.x_, sub_field_info_of_record);
            }
        }
        ++record_counter;
    }
    UpdateJournalValidity(journal_cache, online_issn_cache, printed_issn_cache);

    return journal_cache;
}


void ISSNLookup(char **argv, std::map<std::string, SubFieldInfo> &journal_cache) {
    auto input_file(MARC::Reader::Factory(argv[1]));
    auto output_file(MARC::Writer::Factory(argv[3]));
    unsigned updated_counter(0), invalid_counter(0), failed_counter(0);
    std::vector<std::string> updated_ppn, ignored_ppn;

    while (MARC::Record record = input_file->read()) {
        std::string ppn("");
        for (auto &field : record) {
            if (field.getTag() == "001")
                ppn = field.getContents();

            if (field.getTag() == "773") {
                const std::string issn(field.getFirstSubfieldWithCode('x'));
                if (not issn.empty()) {
                    // data is found
                    auto cache_sfi = journal_cache.cbegin();
                    while (cache_sfi != journal_cache.cend()) {
                        if (cache_sfi->second.x_ == issn || cache_sfi->second.l_ == issn) {
                            MARC::Subfields subfields(field.getSubfields());
                            UpdateSubfield(subfields, journal_cache[issn]);
                            field.setSubfields(subfields);
                            LOG_INFO(ppn + "/" + issn + ": Updated to " + field.getFirstSubfieldWithCode('x'));
                            ++updated_counter;
                        }
                    }
                }
            }
        }
        output_file->write(record);
    }
    LOG_INFO("Lookup result: Updated (" + std::to_string(updated_counter) + "), invalid (" + std::to_string(invalid_counter) + "), failed ("
             + std::to_string(failed_counter) + ")");
}


} // end of namespace


int Main(int argc, char **argv) {
    if (argc != 4)
        Usage();

    std::map<std::string, SubFieldInfo> journal_cache(BuildJournalCache(argv[2]));
    ISSNLookup(argv, journal_cache);

    return EXIT_SUCCESS;
}
